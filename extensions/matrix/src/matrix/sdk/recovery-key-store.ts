import fs from "node:fs";
import path from "node:path";
import type {
  MatrixCryptoBootstrapApi,
  MatrixCryptoCallbacks,
  MatrixGeneratedSecretStorageKey,
  MatrixSecretStorageStatus,
  MatrixStoredRecoveryKey,
} from "./types.js";
import { LogService } from "./logger.js";

export class MatrixRecoveryKeyStore {
  private readonly secretStorageKeyCache = new Map<
    string,
    { key: Uint8Array; keyInfo?: MatrixStoredRecoveryKey["keyInfo"] }
  >();

  constructor(private readonly recoveryKeyPath?: string) {}

  buildCryptoCallbacks(): MatrixCryptoCallbacks {
    return {
      getSecretStorageKey: async ({ keys }) => {
        const requestedKeyIds = Object.keys(keys ?? {});
        if (requestedKeyIds.length === 0) {
          return null;
        }

        for (const keyId of requestedKeyIds) {
          const cached = this.secretStorageKeyCache.get(keyId);
          if (cached) {
            return [keyId, new Uint8Array(cached.key)];
          }
        }

        const stored = this.loadStoredRecoveryKey();
        if (!stored || !stored.privateKeyBase64) {
          return null;
        }
        const privateKey = new Uint8Array(Buffer.from(stored.privateKeyBase64, "base64"));
        if (privateKey.length === 0) {
          return null;
        }

        if (stored.keyId && requestedKeyIds.includes(stored.keyId)) {
          this.rememberSecretStorageKey(stored.keyId, privateKey, stored.keyInfo);
          return [stored.keyId, privateKey];
        }

        const firstRequestedKeyId = requestedKeyIds[0];
        if (!firstRequestedKeyId) {
          return null;
        }
        this.rememberSecretStorageKey(firstRequestedKeyId, privateKey, stored.keyInfo);
        return [firstRequestedKeyId, privateKey];
      },
      cacheSecretStorageKey: (keyId, keyInfo, key) => {
        const privateKey = new Uint8Array(key);
        const normalizedKeyInfo: MatrixStoredRecoveryKey["keyInfo"] = {
          passphrase: keyInfo?.passphrase,
          name: typeof keyInfo?.name === "string" ? keyInfo.name : undefined,
        };
        this.rememberSecretStorageKey(keyId, privateKey, normalizedKeyInfo);

        const stored = this.loadStoredRecoveryKey();
        this.saveRecoveryKeyToDisk({
          keyId,
          keyInfo: normalizedKeyInfo,
          privateKey,
          encodedPrivateKey: stored?.encodedPrivateKey,
        });
      },
    };
  }

  getRecoveryKeySummary(): {
    encodedPrivateKey?: string;
    keyId?: string | null;
    createdAt?: string;
  } | null {
    const stored = this.loadStoredRecoveryKey();
    if (!stored) {
      return null;
    }
    return {
      encodedPrivateKey: stored.encodedPrivateKey,
      keyId: stored.keyId,
      createdAt: stored.createdAt,
    };
  }

  async bootstrapSecretStorageWithRecoveryKey(crypto: MatrixCryptoBootstrapApi): Promise<void> {
    let status: MatrixSecretStorageStatus | null = null;
    if (typeof crypto.getSecretStorageStatus === "function") {
      try {
        status = await crypto.getSecretStorageStatus();
      } catch (err) {
        LogService.warn("MatrixClientLite", "Failed to read secret storage status:", err);
      }
    }

    const hasDefaultSecretStorageKey = Boolean(status?.defaultKeyId);
    const hasKnownInvalidSecrets = Object.values(status?.secretStorageKeyValidityMap ?? {}).some(
      (valid) => valid === false,
    );
    let generatedRecoveryKey = false;
    const storedRecovery = this.loadStoredRecoveryKey();
    let recoveryKey = storedRecovery
      ? {
          keyInfo: storedRecovery.keyInfo,
          privateKey: new Uint8Array(Buffer.from(storedRecovery.privateKeyBase64, "base64")),
          encodedPrivateKey: storedRecovery.encodedPrivateKey,
        }
      : null;

    if (recoveryKey && status?.defaultKeyId) {
      const defaultKeyId = status.defaultKeyId;
      this.rememberSecretStorageKey(defaultKeyId, recoveryKey.privateKey, recoveryKey.keyInfo);
      if (storedRecovery?.keyId !== defaultKeyId) {
        this.saveRecoveryKeyToDisk({
          keyId: defaultKeyId,
          keyInfo: recoveryKey.keyInfo,
          privateKey: recoveryKey.privateKey,
          encodedPrivateKey: recoveryKey.encodedPrivateKey,
        });
      }
    }

    const ensureRecoveryKey = async (): Promise<MatrixGeneratedSecretStorageKey> => {
      if (recoveryKey) {
        return recoveryKey;
      }
      if (typeof crypto.createRecoveryKeyFromPassphrase !== "function") {
        throw new Error(
          "Matrix crypto backend does not support recovery key generation (createRecoveryKeyFromPassphrase missing)",
        );
      }
      recoveryKey = await crypto.createRecoveryKeyFromPassphrase();
      this.saveRecoveryKeyToDisk(recoveryKey);
      generatedRecoveryKey = true;
      return recoveryKey;
    };

    const shouldRecreateSecretStorage =
      !hasDefaultSecretStorageKey ||
      (!recoveryKey && status?.ready === false) ||
      hasKnownInvalidSecrets;

    if (hasKnownInvalidSecrets) {
      // Existing secret storage keys can't decrypt required secrets. Generate a fresh recovery key.
      recoveryKey = null;
    }

    const secretStorageOptions: {
      createSecretStorageKey?: () => Promise<MatrixGeneratedSecretStorageKey>;
      setupNewSecretStorage?: boolean;
      setupNewKeyBackup?: boolean;
    } = {
      setupNewKeyBackup: false,
    };

    if (shouldRecreateSecretStorage) {
      secretStorageOptions.setupNewSecretStorage = true;
      secretStorageOptions.createSecretStorageKey = ensureRecoveryKey;
    }

    await crypto.bootstrapSecretStorage(secretStorageOptions);

    if (generatedRecoveryKey && this.recoveryKeyPath) {
      LogService.warn(
        "MatrixClientLite",
        `Generated Matrix recovery key and saved it to ${this.recoveryKeyPath}. Keep this file secure.`,
      );
    }
  }

  private rememberSecretStorageKey(
    keyId: string,
    key: Uint8Array,
    keyInfo?: MatrixStoredRecoveryKey["keyInfo"],
  ): void {
    if (!keyId.trim()) {
      return;
    }
    this.secretStorageKeyCache.set(keyId, {
      key: new Uint8Array(key),
      keyInfo,
    });
  }

  private loadStoredRecoveryKey(): MatrixStoredRecoveryKey | null {
    if (!this.recoveryKeyPath) {
      return null;
    }
    try {
      if (!fs.existsSync(this.recoveryKeyPath)) {
        return null;
      }
      const raw = fs.readFileSync(this.recoveryKeyPath, "utf8");
      const parsed = JSON.parse(raw) as Partial<MatrixStoredRecoveryKey>;
      if (
        parsed.version !== 1 ||
        typeof parsed.createdAt !== "string" ||
        typeof parsed.privateKeyBase64 !== "string" ||
        !parsed.privateKeyBase64.trim()
      ) {
        return null;
      }
      return {
        version: 1,
        createdAt: parsed.createdAt,
        keyId: typeof parsed.keyId === "string" ? parsed.keyId : null,
        encodedPrivateKey:
          typeof parsed.encodedPrivateKey === "string" ? parsed.encodedPrivateKey : undefined,
        privateKeyBase64: parsed.privateKeyBase64,
        keyInfo:
          parsed.keyInfo && typeof parsed.keyInfo === "object"
            ? {
                passphrase: parsed.keyInfo.passphrase,
                name: typeof parsed.keyInfo.name === "string" ? parsed.keyInfo.name : undefined,
              }
            : undefined,
      };
    } catch {
      return null;
    }
  }

  private saveRecoveryKeyToDisk(params: MatrixGeneratedSecretStorageKey): void {
    if (!this.recoveryKeyPath) {
      return;
    }
    try {
      const payload: MatrixStoredRecoveryKey = {
        version: 1,
        createdAt: new Date().toISOString(),
        keyId: typeof params.keyId === "string" ? params.keyId : null,
        encodedPrivateKey: params.encodedPrivateKey,
        privateKeyBase64: Buffer.from(params.privateKey).toString("base64"),
        keyInfo: params.keyInfo
          ? {
              passphrase: params.keyInfo.passphrase,
              name: params.keyInfo.name,
            }
          : undefined,
      };
      fs.mkdirSync(path.dirname(this.recoveryKeyPath), { recursive: true });
      fs.writeFileSync(this.recoveryKeyPath, JSON.stringify(payload, null, 2), "utf8");
      fs.chmodSync(this.recoveryKeyPath, 0o600);
    } catch (err) {
      LogService.warn("MatrixClientLite", "Failed to persist recovery key:", err);
    }
  }
}
