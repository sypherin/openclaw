diff --git a/dist/providers/google-gemini-cli.js b/dist/providers/google-gemini-cli.js
index 93aa26c395e9bd0df64376408a13d15ee9e7cce7..beb585e2f2c13eec3bca98acade761101e4572ff 100644
--- a/dist/providers/google-gemini-cli.js
+++ b/dist/providers/google-gemini-cli.js
@@ -248,6 +248,11 @@ export const streamGoogleGeminiCli = (model, context, options) => {
                         break; // Success, exit retry loop
                     }
                     const errorText = await response.text();
+                    // Fail immediately on 429 for Antigravity to let callers rotate accounts.
+                    // Antigravity rate limits can have very long retry delays (10+ minutes).
+                    if (isAntigravity && response.status === 429) {
+                        throw new Error(`Cloud Code Assist API error (${response.status}): ${errorText}`);
+                    }
                     // Check if retryable
                     if (attempt < MAX_RETRIES && isRetryableError(response.status, errorText)) {
                         // Use server-provided delay or exponential backoff
diff --git a/dist/providers/openai-codex-responses.js b/dist/providers/openai-codex-responses.js
index 188a8294f26fe1bfe3fb298a7f58e4d8eaf2a529..a3aeb6a7ff53bc4f7f44362adb950b2c55455332 100644
--- a/dist/providers/openai-codex-responses.js
+++ b/dist/providers/openai-codex-responses.js
@@ -433,9 +433,15 @@ function convertMessages(model, context) {
         }
         else if (msg.role === "assistant") {
             const output = [];
+            // OpenAI Responses rejects `reasoning` items that are not followed by a `message`.
+            // Tool-call-only turns (thinking + function_call) are valid assistant turns, but
+            // their stored reasoning items must not be replayed as standalone `reasoning` input.
+            const hasTextBlock = msg.content.some((b) => b.type === "text");
             for (const block of msg.content) {
                 if (block.type === "thinking" && msg.stopReason !== "error") {
                     if (block.thinkingSignature) {
+                        if (!hasTextBlock)
+                            continue;
                         const reasoningItem = JSON.parse(block.thinkingSignature);
                         output.push(reasoningItem);
                     }
@@ -470,6 +476,16 @@ function convertMessages(model, context) {
             }
             if (output.length === 0)
                 continue;
+            // OpenAI rejects standalone reasoning items when replaying a tool-only turn.
+            // Only submit reasoning items when we also submit an assistant message item.
+            // Repro: pnpm test src/agents/openai-responses.reasoning-replay.test.ts
+            const hasMessage = output.some((item) => item?.type === "message");
+            if (!hasMessage) {
+                for (let i = output.length - 1; i >= 0; i -= 1) {
+                    if (output[i]?.type === "reasoning")
+                        output.splice(i, 1);
+                }
+            }
             messages.push(...output);
         }
         else if (msg.role === "toolResult") {
@@ -515,7 +531,7 @@ function convertTools(tools) {
         name: tool.name,
         description: tool.description,
         parameters: tool.parameters,
-        strict: null,
+        strict: false,
     }));
 }
 function mapStopReason(status) {
diff --git a/dist/providers/openai-responses.js b/dist/providers/openai-responses.js
index f07085c64390b211340d6a826b28ea9c2e77302f..523ed38a5a6151d6ff08dd89120315e7aaaf19b6 100644
--- a/dist/providers/openai-responses.js
+++ b/dist/providers/openai-responses.js
@@ -436,6 +436,16 @@ function convertMessages(model, context) {
             }
             if (output.length === 0)
                 continue;
+            // OpenAI rejects standalone reasoning items when replaying a tool-only turn.
+            // Only submit reasoning items when we also submit an assistant message item.
+            // Repro: pnpm test src/agents/openai-responses.reasoning-replay.test.ts
+            const hasMessage = output.some((item) => item?.type === "message");
+            if (!hasMessage) {
+                for (let i = output.length - 1; i >= 0; i -= 1) {
+                    if (output[i]?.type === "reasoning")
+                        output.splice(i, 1);
+                }
+            }
             messages.push(...output);
         }
         else if (msg.role === "toolResult") {
